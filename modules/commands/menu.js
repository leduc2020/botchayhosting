module.exports.config = {
<<<<<<< HEAD
	name: 'menu',
	version: '1.1.1',
	hasPermssion: 0,
	credits: 'DC-Nam mod by Vtuan & DongDev fix',
	description: 'Xem danh s√°ch nh√≥m l·ªánh, th√¥ng tin l·ªánh',
	commandCategory: 'Nh√≥m',
	usages: '[...name commands|all]',
	cooldowns: 1,
	images: [],
	envConfig: {
		autoUnsend: {
			status: true,
			timeOut: 300
		}
	}
};

const { autoUnsend = this.config.envConfig.autoUnsend } = global.config == undefined ? {} : global.config.menu == undefined ? {} : global.config.menu;
const { compareTwoStrings, findBestMatch } = require('string-similarity');
const { readFileSync, writeFileSync, existsSync } = require('fs-extra');

module.exports.run = async function ({ api, event, args }) {
	const moment = require("moment-timezone");
	const { sendMessage: send, unsendMessage: un } = api;
	const { threadID: tid, messageID: mid, senderID: sid } = event;
	const cmds = global.client.commands;

	const time = moment.tz("Asia/Ho_Chi_Minh").format("HH:mm:ss || DD/MM/YYYY");

	if (args.length >= 1) {
		if (typeof cmds.get(args.join(' ')) == 'object') {
			const body = infoCmds(cmds.get(args.join(' ')).config);
			return send(body, tid, mid);
		} else {
			if (args[0] == 'all') {
				const data = cmds.values();
				var txt = '[ BOT MENU LIST ALL ]\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n',
					count = 0;
				for (const cmd of data) txt += `|‚Ä∫ ${++count}. ${cmd.config.name} | ${cmd.config.description}\n`;
				txt += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n|‚Ä∫ ‚è≥ T·ª± ƒë·ªông g·ª° tin nh·∫Øn sau: ${autoUnsend.timeOut}s`;
				return send({ body: txt, attachment: global.ytb_rst2.length > 0 ? global.ytb_rst2.splice(0, 1) : undefined }, tid, (a, b) => autoUnsend.status ? setTimeout(v1 => un(v1), 1000 * autoUnsend.timeOut, b.messageID) : '');
			} else {
				const cmdsValue = cmds.values();
				const arrayCmds = [];
				for (const cmd of cmdsValue) arrayCmds.push(cmd.config.name);
				const similarly = findBestMatch(args.join(' '), arrayCmds);
				if (similarly.bestMatch.rating >= 0.3) return send(` "${args.join(' ')}" l√† l·ªánh g·∫ßn gi·ªëng l√† "${similarly.bestMatch.target}" ?`, tid, mid);
			}
		}
	} else {
		const data = commandsGroup();
		var txt = '[ BOT MENU LIST ]\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n', count = 0;
		for (const { commandCategory, commandsName } of data) txt += `|‚Ä∫ ${++count}. ${commandCategory} || c√≥ ${commandsName.length} l·ªánh\n`;
		txt += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n|‚Ä∫ üìù T·ªïng c√≥: ${global.client.commands.size} l·ªánh\n|‚Ä∫ ‚è∞ Time: ${time}\n|‚Ä∫ üîé Reply t·ª´ 1 ƒë·∫øn ${data.length} ƒë·ªÉ ch·ªçn\n|‚Ä∫ ‚è≥ T·ª± ƒë·ªông g·ª° tin nh·∫Øn sau: ${autoUnsend.timeOut}s`;
		return send({ body: txt }, tid, (a, b) => {
			global.client.handleReply.push({ name: this.config.name, messageID: b.messageID, author: sid, 'case': 'infoGr', data });
			if (autoUnsend.status) setTimeout(v1 => un(v1), 5000 * autoUnsend.timeOut, b.messageID);
		}, mid);
	}
};

module.exports.handleReply = async function ({ handleReply: $, api, event }) {
	const { sendMessage: send, unsendMessage: un } = api;
	const { threadID: tid, messageID: mid, senderID: sid, args } = event;

	if (sid != $.author) {
		const msg = `‚õî C√∫t ra ch·ªó kh√°c`;
		return send(msg, tid, mid);
	}

	switch ($.case) {
		case 'infoGr': {
			var data = $.data[(+args[0]) - 1];
			if (data == undefined) {
				const txt = `‚ùé "${args[0]}" kh√¥ng n·∫±m trong s·ªë th·ª© t·ª± menu`;
				const msg = txt;
				return send(msg, tid, mid);
			}

			un($.messageID);
			var txt = `=== [ ${data.commandCategory} ] ===\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`,
				count = 0;
			for (const name of data.commandsName) {
				const cmdInfo = global.client.commands.get(name).config;
				txt += `|‚Ä∫ ${++count}. ${name} | ${cmdInfo.description}\n`;
			}
			txt += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n|‚Ä∫ üîé Reply t·ª´ 1 ƒë·∫øn ${data.commandsName.length} ƒë·ªÉ ch·ªçn\n|‚Ä∫ ‚è≥ T·ª± ƒë·ªông g·ª° tin nh·∫Øn sau: ${autoUnsend.timeOut}s\n|‚Ä∫ üìù D√πng ${prefix(tid)}help + t√™n l·ªánh ƒë·ªÉ xem chi ti·∫øt c√°ch s·ª≠ d·ª•ng l·ªánh`;
			return send({ body: txt }, tid, (a, b) => {
				global.client.handleReply.push({ name: this.config.name, messageID: b.messageID, author: sid, 'case': 'infoCmds', data: data.commandsName });
				if (autoUnsend.status) setTimeout(v1 => un(v1), 5000 * autoUnsend.timeOut, b.messageID);
			});
		}
		case 'infoCmds': {
			var data = global.client.commands.get($.data[(+args[0]) - 1]);
			if (typeof data != 'object') {
				const txt = `‚ö†Ô∏è "${args[0]}" kh√¥ng n·∫±m trong s·ªë th·ª© t·ª± menu`;
				const msg = txt;
				return send(msg, tid, mid);
			}

			const { config = {} } = data || {};
			un($.messageID);
			const msg = infoCmds(config);
			return send(msg, tid, mid);
		}
		default:
	}
};

function commandsGroup() {
	const array = [],
		cmds = global.client.commands.values();
	for (const cmd of cmds) {
		const { name, commandCategory } = cmd.config;
		const find = array.find(i => i.commandCategory == commandCategory)
		!find ? array.push({ commandCategory, commandsName: [name] }) : find.commandsName.push(name);
	}
	array.sort(sortCompare('commandsName'));
	return array;
}

function infoCmds(a) {
	return `[ INFO - COMMANDS ]\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n|‚Ä∫ üìî T√™n l·ªánh: ${a.name}\n|‚Ä∫ üå¥ Phi√™n b·∫£n : ${a.version}\n|‚Ä∫ üîê Quy·ªÅn h·∫°n : ${premssionTxt(a.hasPermssion)}\n|‚Ä∫ üë§ T√°c gi·∫£ : ${a.credits}\n|‚Ä∫ üåæ M√¥ t·∫£ : ${a.description}\n|‚Ä∫ üìé Thu·ªôc nh√≥m : ${a.commandCategory}\n|‚Ä∫ üìù C√°ch d√πng : ${a.usages}\n|‚Ä∫ ‚è≥ Th·ªùi gian ch·ªù : ${a.cooldowns} gi√¢y\n`;
}

function premssionTxt(a) {
	return a == 0 ? 'Th√†nh Vi√™n' : a == 1 ? 'Qu·∫£n Tr·ªã Vi√™n Nh√≥m' : a == 2 ? 'ADMINBOT' : 'Ng∆∞·ªùi ƒêi·ªÅu H√†nh Bot';
}

function prefix(a) {
	const tidData = global.data.threadData.get(a) || {};
	return tidData.PREFIX || global.config.PREFIX;
}

function sortCompare(k) {
	return function (a, b) {
		return (a[k].length > b[k].length ? 1 : a[k].length < b[k].length ? -1 : 0) * -1;
	};
}
=======

  name: 'menu',

  version: '2.2.0',

  hasPermssion: 0,

  credits: 'DC-Nam mod by Gojo Satoru',

  description: 'Hi·ªÉn th·ªã menu l·ªánh t√πy ch·ªânh theo quy·ªÅn h·∫°n ng∆∞·ªùi d√πng',

  commandCategory: 'Ti·ªán √≠ch',

  usages: '[t√™n l·ªánh | all]',

  cooldowns: 5,

  envConfig: {

    autoUnsend: {

      status: true,

      timeOut: 90,

      usePrefix: false

    }

  }

};

const { autoUnsend = module.exports.config.envConfig.autoUnsend } = global.config?.menu || {};

const { findBestMatch } = require('string-similarity');

async function getThreadAdminIDs(api, threadID) {

  try {

    const threadInfo = await api.getThreadInfo(threadID);

    return threadInfo.adminIDs.map(admin => admin.id);

  } catch (error) {

    console.error("L·ªói khi l·∫•y danh s√°ch admin:", error);

    return [];

  }

}

function canAccessCommand(cmdPermssion, userPermssion, isGroupAdmin) {

  if (userPermssion === 3) return true; // ADMINBOT c√≥ th·ªÉ truy c·∫≠p m·ªçi l·ªánh

  if (userPermssion === 2) return cmdPermssion <= 2; // Ng∆∞·ªùi ƒëi·ªÅu h√†nh bot c√≥ th·ªÉ truy c·∫≠p l·ªánh c√≥ permssion <= 2

  if (isGroupAdmin) return cmdPermssion <= 1; // Admin nh√≥m c√≥ th·ªÉ truy c·∫≠p l·ªánh c√≥ permssion <= 1

  return cmdPermssion === 0; // Th√†nh vi√™n th∆∞·ªùng ch·ªâ c√≥ th·ªÉ truy c·∫≠p l·ªánh c√≥ permssion = 0

}

function permissionTxt(permission) {

  return permission === 0 ? 'üë• Th√†nh Vi√™n' :

         permission === 1 ? 'üëë Qu·∫£n Tr·ªã Vi√™n Nh√≥m' :

         permission === 2 ? 'üõ†Ô∏è Ng∆∞·ªùi ƒêi·ªÅu H√†nh Bot' : 'üåü ADMINBOT';

}

function infoCmds(config) {

  return `‚ï≠‚îÅ‚îÅ‚îÅ„Äé ‚ÑπÔ∏è ${config.name} ‚ÑπÔ∏è „Äè‚îÅ‚îÅ‚îÅ‚ïÆ\n` +

         `‚îÉ üî¢ Phi√™n b·∫£n: ${config.version}\n` +

         `‚îÉ üîê Quy·ªÅn h·∫°n: ${permissionTxt(config.hasPermssion)}\n` +

         `‚îÉ üë§ T√°c gi·∫£  : ${config.credits}\n` +

         `‚îÉ üìù M√¥ t·∫£    : ${config.description}\n` +

         `‚îÉ üìÅ Nh√≥m l·ªánh: ${config.commandCategory}\n` +

         `‚îÉ üîß C√°ch d√πng: ${config.usages}\n` +

         `‚îÉ ‚è±Ô∏è Th·ªùi gian ch·ªù: ${config.cooldowns} gi√¢y\n` +

         `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;

}

function getRandomIcons(count) {

  const allIcons = ['üåü', 'üöÄ', 'üí°', 'üî•', 'üéà', 'üéâ', 'üéä', 'üèÜ', 'üèÖ', 'ü•á', 'ü•à', 'ü•â', 'üéñÔ∏è', 'üèµÔ∏è', 'üéóÔ∏è', 'üéØ', 'üé≠', 'üé®', 'üé¨', 'üé§', 'üéß', 'üéº', 'üéπ', 'ü•Å', 'üé∑', 'üé∫', 'üé∏', 'ü™ï', 'üéª', 'üé≤', 'üéÆ', 'üïπÔ∏è', 'üé∞', 'üé≥', 'üèè', 'üèë', 'üèí', 'üèì', 'üè∏', 'ü•ä', 'ü•ã', 'ü•Ö', '‚õ≥', '‚õ∏Ô∏è', 'üé£', 'ü§ø', 'üéΩ', 'üéø', 'üõ∑', 'ü•å', 'üé±', 'ü™Ä', 'üèπ', 'üé¢', 'üé°', 'üé†'];

  return [...allIcons].sort(() => 0.5 - Math.random()).slice(0, count);

}

function commandsGroup(permssion, isGroupAdmin) {

  const groups = [];

  for (const [name, cmd] of global.client.commands) {

    if (canAccessCommand(cmd.config.hasPermssion, permssion, isGroupAdmin)) {

      const { commandCategory } = cmd.config;

      const group = groups.find(g => g.commandCategory === commandCategory);

      if (group) {

        group.commandsName.push(name);

      } else {

        groups.push({ commandCategory, commandsName: [name] });

      }

    }

  }

  return groups.sort((a, b) => b.commandsName.length - a.commandsName.length);

}

function findSimilarCommands(input, commands, limit = 3) {

  const matches = findBestMatch(input, commands);

  return matches.ratings

    .filter(match => match.rating > 0.3)

    .sort((a, b) => b.rating - a.rating)

    .slice(0, limit)

    .map(match => match.target);

}

async function sendFullCommandList(api, send, tid, mid, isAdmin, isGroupAdmin, permssion) {

  const cmds = Array.from(global.client.commands.values()).filter(cmd => 

    canAccessCommand(cmd.config.hasPermssion, permssion, isGroupAdmin)

  );

  let txt = '‚ï≠‚îÄ‚îÄ‚îÄ„Äé All Commands „Äè‚îÄ‚îÄ‚îÄ‚ïÆ\n';

  cmds.forEach((cmd, index) => {

    txt += `‚îÉ ${index + 1}. ${cmd.config.name}\n`;

  });

  txt += `‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\nüî∏ D√πng "menu + t√™n l·ªánh" ƒë·ªÉ xem chi ti·∫øt\nüî∏ G·ª° t·ª± ƒë·ªông sau: ${autoUnsend.timeOut}s`;

  send(txt, tid, (error, info) => {

    if (autoUnsend.status) setTimeout(() => api.unsendMessage(info.messageID), autoUnsend.timeOut * 1000);

  });

}

module.exports.run = async function({ api, event, args, permssion }) {

  const { sendMessage: send, unsendMessage: un } = api;

  const { threadID: tid, messageID: mid, senderID: sid } = event;

  const cmds = global.client.commands;

  const isAdmin = permssion === 2 || permssion === 3;

  const adminIDs = await getThreadAdminIDs(api, tid);

  const isGroupAdmin = adminIDs.includes(sid);

  if (args.length >= 1) {

    if (args[0].toLowerCase() === 'all') {

      return await sendFullCommandList(api, send, tid, mid, isAdmin, isGroupAdmin, permssion);

    }

    const cmdName = args.join(' ').toLowerCase();

    const cmd = cmds.get(cmdName) || cmds.find(c => c.config.name.toLowerCase() === cmdName);

    if (cmd && canAccessCommand(cmd.config.hasPermssion, permssion, isGroupAdmin)) {

      return send(infoCmds(cmd.config), tid, mid);

    } else {

      const accessibleCommands = Array.from(cmds.keys()).filter(name => {

        const cmd = cmds.get(name);

        return canAccessCommand(cmd.config.hasPermssion, permssion, isGroupAdmin);

      });

      const similarCommands = findSimilarCommands(cmdName, accessibleCommands);

      if (similarCommands.length > 0) {

        return send(`‚ùì Kh√¥ng t√¨m th·∫•y l·ªánh "${cmdName}". C√≥ ph·∫£i b·∫°n mu·ªën t√¨m:\n${similarCommands.join('\n')}`, tid, mid);

      } else {

        return send(`‚ùå Kh√¥ng t√¨m th·∫•y l·ªánh "${cmdName}" ho·∫∑c b·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p.`, tid, mid);

      }

    }

  } else {

    const data = commandsGroup(permssion, isGroupAdmin);

    const icons = getRandomIcons(data.length);

    let txt = '‚ï≠‚îÅ‚îÅ‚îÅ„Äé üåü Menu Yuz üåü „Äè‚îÅ‚îÅ‚ïÆ\n';

    for (let i = 0; i < data.length; i++) {

      const { commandCategory, commandsName } = data[i];

      txt += `‚îÉ ${i + 1}. ${icons[i]} ${commandCategory}: ${commandsName.length} l·ªánh\n`;

    }

    txt += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n` +

           `‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïÆ\n` + 

           `‚îÉ  ${data.reduce((sum, group) => sum + group.commandsName.length, 0)} l·ªánh.\n` +

           `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n` +

           `üìù Reply s·ªë t·ª´ 1 ƒë·∫øn ${data.length} ƒë·ªÉ xem chi ti·∫øt\n` +

           `üí° G√µ "menu all" ƒë·ªÉ xem t·∫•t c·∫£ l·ªánh c√≥ th·ªÉ truy c·∫≠p\n` +

           `‚è±Ô∏è T·ª± ƒë·ªông g·ª° sau: ${autoUnsend.timeOut}s\n` +

           `üì± Facebook Admin: ${global.config.FACEBOOK_ADMIN || "https://www.facebook.com/profile.php?id=61550528673840"}`;

    

    send(txt, tid, (error, info) => {

      global.client.handleReply.push({

        name: this.config.name,

        messageID: info.messageID,

        author: sid,

        'case': 'infoGr',

        data,

        permssion,

        isGroupAdmin

      });

      if (autoUnsend.status) setTimeout(() => un(info.messageID), autoUnsend.timeOut * 1000);

    });

  }

};

module.exports.handleReply = async function({ handleReply: $, api, event }) {

  const { sendMessage: send, unsendMessage: un } = api;

  const { threadID: tid, messageID: mid, senderID: sid, body } = event;

  const args = body.split(' ');

  

  if (sid != $.author) {

    return send(`üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y`, tid, mid);

  }

  

  switch ($.case) {

    case 'infoGr': {

      const data = $.data[parseInt(args[0]) - 1];

      if (!data) {

        return send(`‚ùå "${args[0]}" kh√¥ng n·∫±m trong s·ªë th·ª© t·ª± menu`, tid, mid);

      }

      un($.messageID);

      const icons = getRandomIcons(data.commandsName.length);

      let txt = `‚ï≠‚îÅ‚îÅ‚îÅ„Äé üìÅ ${data.commandCategory} üìÅ „Äè‚îÅ‚îÅ‚îÅ‚ïÆ\n`;

      for (let i = 0; i < data.commandsName.length; i++) {

        txt += `‚îÉ ${i + 1}. ${icons[i]} ${data.commandsName[i]}\n`;

      }

      txt += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n` +

             `üìù Reply t·ª´ 1 ƒë·∫øn ${data.commandsName.length} ƒë·ªÉ xem chi ti·∫øt l·ªánh\n` +

             `‚è±Ô∏è T·ª± ƒë·ªông g·ª° sau: ${autoUnsend.timeOut}s`;

      send(txt, tid, (error, info) => {

        global.client.handleReply.push({

          name: this.config.name,

          messageID: info.messageID,

          author: sid,

          'case': 'infoCmds',

          data: data.commandsName,

          permssion: $.permssion,

          isGroupAdmin: $.isGroupAdmin

        });

        if (autoUnsend.status) setTimeout(() => un(info.messageID), autoUnsend.timeOut * 1000);

      });

      break;

    }

    case 'infoCmds': {

      const cmdName = $.data[parseInt(args[0]) - 1];

      const cmd = global.client.commands.get(cmdName);

      if (!cmd || !canAccessCommand(cmd.config.hasPermssion, $.permssion, $.isGroupAdmin)) {

        return send(`‚ùå "${args[0]}" kh√¥ng n·∫±m trong s·ªë th·ª© t·ª± menu ho·∫∑c b·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p`, tid, mid);

      }

      un($.messageID);

      send(infoCmds(cmd.config), tid, mid);

      break;

    }

  }

};
>>>>>>> 4398b3a5fd9045b8de57d496d6bc325c61036aaa
