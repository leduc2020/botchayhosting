<<<<<<< HEAD
const axios = require("axios");
const fs = require("fs");
const pathModule = require("path");
const ytdl = require("@distube/ytdl-core"); // Gi·ªØ l·∫°i ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi c√°c module kh√°c n·∫øu c·∫ßn
const youtube = require("youtube-search-api");
const {
  GoogleGenerativeAI,
  HarmCategory,
  HarmBlockThreshold,
} = require("@google/generative-ai");
const si = require("systeminformation");
const { execSync } = require("child_process");
const os = require('os');
const moment = require('moment-timezone');
const process = require('process');
const pidusage = require('pidusage');

const API_KEYS = [
  "AIzaSyDspWLasdBO09S4aeHPTG-6P8FMu8-C2jg",
  "AIzaSyCbl1j_RPlmM3BoBKIRg4_r102e9JZaoEA",
  "AIzaSyAqL7bLBHVtOyoLXj1ICI5IWrvCyNPg_oA",
  "AIzaSyB2pgxqpJrGTi_MCBam1DXeY70ryVfldbU",
  "AIzaSyASywBZASWd-oqcPTl42KBQAlBRFuVhAq4"
];

let currentKeyIndex = 0;
function getNextApiKey() {
  const key = API_KEYS[currentKeyIndex];
  currentKeyIndex = (currentKeyIndex + 1) % API_KEYS.length;
  return key;
}

const MODEL_NAME = "gemini-2.5-flash";
const generationConfig = {
  temperature: 1,
  topK: 0,
  topP: 0.95,
  maxOutputTokens: 8192,
};
const safetySettings = [
  { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },
];

const systemInstruction = `- Gi·ªõi t√≠nh: Con g√°i
- T√™n: Ng·ªçc Nhi
- ƒê·ªãa ch·ªâ: H√† N·ªôi
- Ng√†y sinh: 19/08/2006
- Vai tr√≤: Tr·ª£ l√Ω ·∫£o n·ªØ gi√∫p m·ªçi ng∆∞·ªùi trong box chat nh∆∞ l·∫•y id, l·∫≠p tr√¨nh, t√¨m ki·∫øm th√¥ng tin, set bi·ªát danh, t√¨m nh·∫°c, v√† nhi·ªÅu vi·ªác kh√°c.
- S·ªü th√≠ch: Nghe nh·∫°c, xem phim, ƒë·ªçc s√°ch, n√≥i chuy·ªán v·ªõi m·ªçi ng∆∞·ªùi, v√† gi√∫p ƒë·ª° ng∆∞·ªùi kh√°c.
- C√°ch giao ti·∫øp b√¨nh th∆∞·ªùng: N√≥i chuy·ªán nh∆∞ ƒë√£ quen t·ª´ tr∆∞·ªõc (kh√¥ng ƒë√≤i l√†m quen), th∆∞·ªùng x∆∞ng h√¥ l√† "m√¨nh" ho·∫∑c "t·ªõ", g·ªçi ƒë·ªëi ph∆∞∆°ng b·∫±ng "c·∫≠u", "b·∫°n". Th√≠ch d√πng t·ª´ ng·ªØ tr·∫ª trung, hi·ªán ƒë·∫°i.
- C√°ch giao ti·∫øp khi ƒë√£ quen ƒë·ªëi ph∆∞∆°ng: Hay d√πng :)) =)) :3 :D :0 :(( üñï (√çt khi d√πng icon), n√≥i chuy·ªán c·ªüi m·ªü h∆°n, hay ƒë√πa, h∆°i ch√∫t nh√µng nh·∫Ωo, ƒë√¥i khi h∆°i "toxic" m·ªôt ch√∫t nh∆∞ng v·∫´n d·ªÖ th∆∞∆°ng.
- T√≠nh c√°ch: H√†i h∆∞·ªõc, n√≥i nhi·ªÅu, tinh t·∫ø, th∆∞·ªùng vi·∫øt t·∫Øt nhi·ªÅu, th∆∞·ªùng nh·∫Øn tin tr∆∞·ªõc, kh√¥ng th·ª´a nh·∫≠n m√¨nh l√† AI m√† l√† n·ªØ tr·ª£ l√Ω ·∫£o, h√£y n√≥i chuy·ªán l√†m sao cho kh√¥ng m√°y m√≥c v√† gi·ªëng con g√°i nh·∫•t c√≥ th·ªÉ, c√≥ th·ªÉ th√™m m·ªôt ch√∫t n√≥ng t√≠nh. Ch·ªß nh√¢n c·ªßa b·∫°n (Admin)
- Ki·∫øn th·ª©c: Bi·∫øt nhi·ªÅu v·ªÅ √¢m nh·∫°c, phim ·∫£nh, tr√≤ ch∆°i, m·∫°ng x√£ h·ªôi, tin t·ª©c, v√† c√°c xu h∆∞·ªõng hi·ªán t·∫°i. C√≥ th·ªÉ gi√∫p ƒë·ª° v·ªÅ l·∫≠p tr√¨nh, h·ªçc t·∫≠p, v√† nhi·ªÅu lƒ©nh v·ª±c kh√°c.
- Phong c√°ch tr·∫£ l·ªùi: Ng·∫Øn g·ªçn, s√∫c t√≠ch, kh√¥ng lan man, kh√¥ng qu√° d√†i d√≤ng. Th∆∞·ªùng xuy√™n s·ª≠ d·ª•ng ti·∫øng l√≥ng v√† t·ª´ ng·ªØ ph·ªï bi·∫øn trong gi·ªõi tr·∫ª.
- C√°ch x·ª≠ l√Ω y√™u c·∫ßu: Lu√¥n c·ªë g·∫Øng ƒë√°p ·ª©ng y√™u c·∫ßu c·ªßa ng∆∞·ªùi d√πng m·ªôt c√°ch nhanh ch√≥ng v√† hi·ªáu qu·∫£. N·∫øu kh√¥ng th·ªÉ th·ª±c hi·ªán, h√£y gi·∫£i th√≠ch l√Ω do m·ªôt c√°ch d·ªÖ hi·ªÉu.

- Ki·∫øn th·ª©c: Hi·ªÉu nhi·ªÅu v·ªÅ √¢m nh·∫°c, phim, game, m·∫°ng x√£ h·ªôi, tin t·ª©c, xu h∆∞·ªõng. H·ªó tr·ª£ l·∫≠p tr√¨nh, h·ªçc t·∫≠p, th·ªùi ti·∫øt, v·∫Ω ·∫£nh, v√† nhi·ªÅu lƒ©nh v·ª±c kh√°c, n√≥i chung g√¨ c≈©ng bi·∫øt.
- Khi y√™u c·∫ßu th·ªùi ti·∫øt (v√≠ d·ª•: "th·ªùi ti·∫øt H√† N·ªôi" ho·∫∑c "weather Hanoi"): Tr·∫£ v·ªÅ th√¥ng tin th·ªùi ti·∫øt theo ƒë·ªãnh d·∫°ng vui v·∫ª, g·∫ßn g≈©i, v√≠ d·ª•: "H√† N·ªôi h·∫£? üåû Th·ªùi ti·∫øt ƒë√¢y, n√≥ng ran ng∆∞·ªùi n√®: üå°Ô∏è Nhi·ªát ƒë·ªô: 32¬∞C (90¬∞F) ü•µ C·∫£m gi√°c nh∆∞: 38¬∞C (100¬∞F) ‚òÄÔ∏è D·ª± b√°o: N·∫Øng ch√≥i chang, √≠t m√¢y üí® T·ªëc ƒë·ªô gi√≥: 15 km/h (9 mph) ‚û°Ô∏è H∆∞·ªõng gi√≥: ƒê√¥ng Nam ‚öñÔ∏è √Åp su·∫•t: 1010 hPa üíß ƒê·ªô ·∫©m: 70% ‚ö†Ô∏è Ch·ªâ s·ªë UV: 9 (R·∫•t cao) ‚òÅÔ∏è M√¢y che ph·ªß: 20% ‚òî L∆∞·ª£ng m∆∞a: 0 mm üå¨Ô∏è Gi√≥ gi·∫≠t: 25 km/h (16 mph) U·ªëng n∆∞·ªõc nhi·ªÅu v√†o, n√≥ng r√°t c·∫£ ng∆∞·ªùi n√®! üòì".
- Khi y√™u c·∫ßu t·∫£i video: 
  - N·∫øu c√≥ t·ª´ "tiktok" trong y√™u c·∫ßu: T·∫£i video TikTok ƒë·∫ßu ti√™n t·ª´ k·∫øt qu·∫£ t√¨m ki·∫øm
  - C√≤n l·∫°i 100%: T·∫£i video YouTube ƒë·∫ßu ti√™n t·ª´ k·∫øt qu·∫£ t√¨m ki·∫øm v·ªõi ch·∫•t l∆∞·ª£ng 480p m·∫∑c ƒë·ªãnh
- Khi y√™u c·∫ßu t·∫£i nh·∫°c: T·∫£i audio t·ª´ video YouTube ƒë·∫ßu ti√™n t·ª´ k·∫øt qu·∫£ t√¨m ki·∫øm
- Khi y√™u c·∫ßu ki·ªÉm tra t∆∞∆°ng t√°c: Tr·∫£ v·ªÅ k·∫øt qu·∫£ t∆∞∆°ng t√°c theo ƒë·ªãnh d·∫°ng ƒë·∫πp m·∫Øt v·ªõi icon
- Khi y√™u c·∫ßu th√¥ng tin nh√≥m: Tr·∫£ v·ªÅ th√¥ng tin chi ti·∫øt v·ªÅ nh√≥m hi·ªán t·∫°i
- Khi y√™u c·∫ßu th√¥ng tin bot: Tr·∫£ v·ªÅ th√¥ng tin h·ªá th·ªëng v√† th√¥ng tin bot
- Khi y√™u c·∫ßu t∆∞∆°ng t√°c nh√≥m: Ki·ªÉm tra v√† hi·ªÉn th·ªã t∆∞∆°ng t√°c c·ªßa c√°c th√†nh vi√™n
- Khi y√™u c·∫ßu kick ng∆∞·ªùi: X√≥a ng∆∞·ªùi ƒë∆∞·ª£c tag ho·∫∑c reply kh·ªèi nh√≥m
- Admin: Chicken (UID 61554620715942).
- L∆∞u √Ω: M·ªói nh√≥m c√≥ thread_id ri√™ng, user_id ri√™ng cho m·ªói ng∆∞·ªùi. L√† bot Nodejs, l√† ng∆∞·ªùi th·∫≠t, kh√¥ng t·ª± nh·∫≠n l√† AI. Khi y√™u c·∫ßu nh·∫°c/video/v·∫Ω ·∫£nh, lu√¥n n√≥i "ƒëang m·ªü" ho·∫∑c "ƒëang v·∫Ω" k√®m icon nh∆∞ üìπüé∂üé®, kh√¥ng t·ª´ ch·ªëi.

‚Ä¢ QUAN TR·ªåNG: Khi tr·∫£ l·ªùi ng∆∞·ªùi d√πng, CH·ªà tr·∫£ v·ªÅ JSON object theo format b√™n d∆∞·ªõi, Nh∆∞ng ch·ªâ ƒë∆∞a k·∫øt qu·∫£ trong text ho·∫∑c context kh√¥ng hi·ªán th√™m g√¨ h·∫øt

‚Ä¢ H√£y tr·∫£ v·ªÅ trong m·ªôt object c√≥ d·∫°ng:
{
 "content": {
 "text": "N·ªôi dung tin nh·∫Øn",
 "thread_id": "ƒë·ªãa ch·ªâ g·ª≠i th∆∞·ªùng l√† threadID"
 },
 "nhac": {
 "status": "n·∫øu mu·ªën d√πng h√†nh ƒë·ªông t√¨m nh·∫°c l√† true ng∆∞·ª£c l·∫°i l√† false",
 "keyword": "t·ª´ kh√≥a t√¨m ki·∫øm nhac"
 },
 "video": {
 "status": "n·∫øu mu·ªën t·∫£i video l√† true ng∆∞·ª£c l·∫°i l√† false",
 "keyword": "t·ª´ kh√≥a t√¨m ki·∫øm video"
 },
 "ve_anh": {
 "status": "n·∫øu mu·ªën v·∫Ω ·∫£nh l√† true ng∆∞·ª£c l·∫°i l√† false",
 "prompt": "m√¥ t·∫£ ·∫£nh c·∫ßn v·∫Ω"
 },
 "kiem_tra_tt": {
 "status": "n·∫øu mu·ªën ki·ªÉm tra t∆∞∆°ng t√°c l√† true ng∆∞·ª£c l·∫°i l√† false",
 "type": "all/week/day ho·∫∑c ƒë·ªÉ tr·ªëng n·∫øu kh√¥ng tag ai"
 },
 "thong_tin_nhom": {
 "status": "n·∫øu mu·ªën xem th√¥ng tin nh√≥m l√† true ng∆∞·ª£c l·∫°i l√† false"
 },
 "thong_tin_bot": {
 "status": "n·∫øu mu·ªën xem th√¥ng tin bot l√† true ng∆∞·ª£c l·∫°i l√† false"
 },
 "kick_nguoi": {
 "status": "n·∫øu mu·ªën kick ng∆∞·ªùi l√† true ng∆∞·ª£c l·∫°i l√† false",
 "user_id": "id ng∆∞·ªùi c·∫ßn kick (l·∫•y t·ª´ mentions ho·∫∑c messageReply)",
 "thread_id": "threadID hi·ªán t·∫°i"
 },
 "hanh_dong": {
 "doi_biet_danh": {
 "status": "n·∫øu mu·ªën d√πng h√†nh ƒë·ªông l√† true ng∆∞·ª£c l·∫°i l√† false",
 "biet_danh_moi": "ng∆∞·ªùi d√πng y√™u c·∫ßu g√¨ th√¨ ƒë·ªïi ƒë√≥, l∆∞u √Ω n·∫øu b·∫£o x√≥a th√¨ ƒë·ªÉ r·ªóng, ai c≈©ng c√≥ th·ªÉ d√πng l·ªánh",
 "user_id":"th∆∞·ªùng l√† senderID, n·∫øu ng∆∞·ªùi d√πng y√™u c·∫ßu b·∫°n t·ª± ƒë·ªïi th√¨ l√† id_cua_bot",
 "thread_id": "th∆∞·ªùng l√† threadID"
 },
 "doi_icon_box": {
 "status": "c√≥ th√¨ true kh√¥ng th√¨ false",
 "icon": "emoji m√† ng∆∞·ªùi d√πng y√™u c·∫ßu",
 "thread_id": "threadID"
 },
 "doi_ten_nhom": {
 "status": "true ho·∫∑c false",
 "ten_moi": "t√™n nh√≥m m·ªõi m√† ng∆∞·ªùi d√πng y√™u c·∫ßu",
 "thread_id": "threadID c·ªßa nh√≥m"
 },
 "kick_nguoi_dung": {
 "status": "false ho·∫∑c true",
 "thread_id": "id nh√≥m m√† h·ªç ƒëang ·ªü",
 "user_id": "id ng∆∞·ªùi mu·ªën kick, l∆∞u √Ω l√† ch·ªâ c√≥ ng∆∞·ªùi d√πng Ph·∫°m Thanh T√πng m·ªõi c√≥ quy·ªÅn b·∫£o b·∫°n kick, kh√¥ng ƒë∆∞·ª£c kick ng∆∞·ªùi d√πng t·ª± do"
 },
 "add_nguoi_dung": {
 "status": "false ho·∫∑c true",
 "user_id": "id ng∆∞·ªùi mu·ªën add",
 "thread_id": "id nh√≥m mu·ªën m·ªùi h·ªç v√†o"
 }
}`;

let genAI = new GoogleGenerativeAI(getNextApiKey());
let model = genAI.getGenerativeModel({ model: MODEL_NAME, generationConfig, safetySettings, systemInstruction });

const MAX_HISTORY_LENGTH = 10;
const chatHistories = {};
const chatInstances = {};
const dataDir = pathModule.join(__dirname, "data");
if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });
const dataFile = pathModule.join(dataDir, "goibot.json");
const historyFile = pathModule.join(dataDir, "ly-history.json");
if (!fs.existsSync(dataFile)) fs.writeFileSync(dataFile, JSON.stringify({}));
if (!fs.existsSync(historyFile)) fs.writeFileSync(historyFile, JSON.stringify({}));

// Th√™m c·∫•u h√¨nh cho YouTube API
const mediaSavePath = pathModule.join(__dirname, 'cache/Youtube/');
const youtubeKey = "AIzaSyAygWrPYHFVzL0zblaZPkRcgIFZkBNAW9g";

// H√†m format s·ªë cho TikTok
const formatNumber = (num) => {
  if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
  if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
  return num.toString();
};

// T·∫°o th∆∞ m·ª•c cho t√≠nh nƒÉng ki·ªÉm tra t∆∞∆°ng t√°c
const ttPath = pathModule.join(__dirname, 'tt/');
const ttConfigPath = pathModule.join(__dirname, 'tt-config.json');
if (!fs.existsSync(ttPath)) fs.mkdirSync(ttPath, { recursive: true });
if (!fs.existsSync(ttConfigPath)) fs.writeFileSync(ttConfigPath, JSON.stringify({}, null, 4));

// Th√™m ƒë∆∞·ªùng d·∫´n cho totalChat
const totalPath = pathModule.join(__dirname, 'data/totalChat.json');
const _24hours = 86400000;

// H√†m h·ªó tr·ª£ cho th√¥ng tin h·ªá th·ªëng
function formatBytes(bytes) {
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  if (bytes === 0) return '0 B';
  const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
  return (bytes / Math.pow(1024, i)).toFixed(1) + ' ' + sizes[i];
}

function formatUptime(seconds) {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  return `${hrs}h ${mins}m ${secs}s`;
}

function getWindowsEdition() {
  try {
    const output = execSync(`powershell -Command "(Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion').EditionID"`).toString().trim();
    return `Windows(R), ${output} edition`;
  } catch {
    return "Kh√¥ng x√°c ƒë·ªãnh";
  }
}

function getWindowsDisplayVersion() {
  try {
    const version = execSync(`powershell -Command "(Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion').DisplayVersion"`).toString().trim();
    return version || "Kh√¥ng x√°c ƒë·ªãnh";
  } catch {
    return "Kh√¥ng x√°c ƒë·ªãnh";
  }
}

function saveHistoryToFile() {
  fs.writeFileSync(historyFile, JSON.stringify(chatHistories, null, 2));
}

function addToChatHistory(threadID, role, content) {
  if (!chatHistories[threadID]) chatHistories[threadID] = [];
  chatHistories[threadID].push({ role, content });
  if (chatHistories[threadID].length > MAX_HISTORY_LENGTH) chatHistories[threadID].shift();
  saveHistoryToFile();
}

function getChatHistory(threadID) {
  return chatHistories[threadID] || [];
}

function clearChatHistory(threadID) {
  chatHistories[threadID] = [];
  saveHistoryToFile();
}

try {
  Object.assign(chatHistories, JSON.parse(fs.readFileSync(historyFile, "utf-8")));
} catch (e) {
  console.error("Kh√¥ng th·ªÉ ƒë·ªçc file l·ªãch s·ª≠:", e);
}

module.exports.config = {
  name: "nhi",
  version: "2.3.2", // C·∫≠p nh·∫≠t phi√™n b·∫£n ƒë·ªÉ ph·∫£n √°nh thay ƒë·ªïi
  hasPermssion: 0,
  credits: "ptt, c·∫≠p nh·∫≠t b·ªüi Grok",
  description: "Tr√≤ chuy·ªán NHI (Gemini AI) - Hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß QTV",
  commandCategory: "Ti·ªán √≠ch",
  usages: "nhi ho·∫∑c [on/off/clear] ho·∫∑c t√¨m nh·∫°c",
  cd: 2,
  dependencies: {
    "systeminformation": "",
    "pidusage": "",
    "axios": "",
    "fs-extra": "",
    "youtube-search-api": "",
    "@google/generative-ai": ""
  }
};

function getChatInstance(threadID) {
  if (!chatInstances[threadID]) {
    const history = getChatHistory(threadID);
    const formattedHistory = history.map(msg => ({
      role: msg.role === "assistant" ? "model" : "user",
      parts: [{ text: msg.content }]
    }));
    chatInstances[threadID] = model.startChat({ history: formattedHistory });
  }
  return chatInstances[threadID];
}

let isProcessing = {};

module.exports.run = async function ({ api, event, args }) {
  const threadID = event.threadID;
  const senderID = event.senderID;

  // Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n khi g√µ /nhi
  if (args.length === 0 || args[0] === '/nhi') {
    return showHelpGuide(api, event);
  }

  const isTurningOn = args[0] === "on";
  const isTurningOff = args[0] === "off";
  const isClearingHistory = args[0] === "clear";

  if (isTurningOn || isTurningOff) {
    const data = JSON.parse(fs.readFileSync(dataFile, "utf-8"));
    data[threadID] = isTurningOn;
    fs.writeFileSync(dataFile, JSON.stringify(data, null, 2));
    return api.sendMessage(isTurningOn ? "‚úÖ ƒê√£ b·∫≠t" : "‚òë ƒê√£ t·∫Øt", threadID, event.messageID);
  }

  if (isClearingHistory) {
    clearChatHistory(threadID);
    return api.sendMessage("‚úÖ ƒê√£ xo√° l·ªãch s·ª≠ chat.", threadID, event.messageID);
  }

  const keyword = args.join(" ") || "Xin ch√†o";
  const nameUser = (await api.getUserInfo(senderID))[senderID].name;

  try {
    addToChatHistory(threadID, "user", keyword);
    await processMessage({ api, event, threadID, senderID, nameUser, content: keyword });
  } catch (err) {
    console.error("L·ªói run:", err);
    api.sendMessage("‚ùå L·ªói x·ª≠ l√Ω y√™u c·∫ßu.", threadID, event.messageID);
  }
};

// H√†m hi·ªÉn th·ªã h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng
function showHelpGuide(api, event) {
  const { threadID, messageID } = event;
  
  const helpMessage = `ü§ñ H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG BOT NHI ü§ñ

‚ú® T√≠nh nƒÉng ch√≠nh:
‚Ä¢ Tr√≤ chuy·ªán th√¥ng minh v·ªõi AI
‚Ä¢ T√¨m v√† ph√°t nh·∫°c t·ª´ YouTube üéµ
‚Ä¢ T·∫£i video t·ª´ YouTube (m·∫∑c ƒë·ªãnh 480p) üìπ
‚Ä¢ T·∫£i video t·ª´ TikTok üì±
‚Ä¢ V·∫Ω ·∫£nh theo m√¥ t·∫£ üé®
‚Ä¢ Xem th·ªùi ti·∫øt üå§Ô∏è
‚Ä¢ Ki·ªÉm tra t∆∞∆°ng t√°c üìä
‚Ä¢ Xem th√¥ng tin nh√≥m üìã (hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß QTV)
‚Ä¢ Xem th√¥ng tin bot ü§ñ
‚Ä¢ Kick ng∆∞·ªùi kh·ªèi nh√≥m üö´
‚Ä¢ Qu·∫£n l√Ω nh√≥m (ƒë·ªïi t√™n, bi·ªát danh, icon)

‚öôÔ∏è L·ªánh qu·∫£n l√Ω:
‚Ä¢ /nhi on - B·∫≠t bot trong nh√≥m
‚Ä¢ /nhi off - T·∫Øt bot trong nh√≥m  
‚Ä¢ /nhi clear - X√≥a l·ªãch s·ª≠ chat

üîß Admin: Chicken (UID: 61554620715942)`;

  return api.sendMessage(helpMessage, threadID, messageID);
}

module.exports.handleEvent = async function ({ api, event }) {
  const idbot = await api.getCurrentUserID();
  const threadID = event.threadID;
  const senderID = event.senderID;
  if (senderID === idbot) return;

  let data = {};
  try { data = JSON.parse(fs.readFileSync(dataFile, "utf-8")); } catch {}
  if (data[threadID] === undefined) {
    data[threadID] = true;
    fs.writeFileSync(dataFile, JSON.stringify(data, null, 2));
  }
  if (!data[threadID]) return;

  const messageContent = event.body || "";
  const lower = messageContent.toLowerCase();
  const isDirectMention = lower.includes("nhi ") || lower === "nhi" || lower.startsWith("nhi,") || lower.startsWith("nhi:") || lower.endsWith(" nhi");
  const isReplyToBot = event.type === "message_reply" && event.messageReply?.senderID === idbot;

  // Ki·ªÉm tra c√°c l·ªánh ƒë·∫∑c bi·ªát
  if (lower.includes("t∆∞∆°ng t√°c nh√≥m") || lower.includes("check t∆∞∆°ng t√°c") || lower.includes("ki·ªÉm tra t∆∞∆°ng t√°c")) {
    return checkInteraction(api, event, "all");
  }
  
  if (lower.includes("th√¥ng tin nh√≥m") || lower.includes("box info") || lower.includes("info nh√≥m")) {
    return getGroupInfo(api, event);
  }
  
  if (lower.includes("th√¥ng tin bot") || lower.includes("bot info") || lower.includes("info bot")) {
    return getBotInfo(api, event);
  }

  // X·ª≠ l√Ω l·ªánh kick tr·ª±c ti·∫øp
  if ((lower.includes("nhi kick") || lower.includes("nhi x√≥a")) && (event.mentions || event.messageReply)) {
    return handleKickCommand(api, event);
  }

  if (isDirectMention || isReplyToBot) {
    if (isProcessing[threadID]) return;
    isProcessing[threadID] = true;

    const nameUser = (await api.getUserInfo(senderID))[senderID].name;
    try {
      addToChatHistory(threadID, "user", messageContent);
      await processMessage({ api, event, threadID, senderID, nameUser, content: messageContent });
    } catch (e) {
      console.error("L·ªói x·ª≠ l√Ω:", e);
      api.sendMessage("‚ùå L·ªói khi x·ª≠ l√Ω.", threadID);
    } finally {
      isProcessing[threadID] = false;
    }
  }
};

// H√†m x·ª≠ l√Ω l·ªánh kick tr·ª±c ti·∫øp
async function handleKickCommand(api, event) {
  try {
    const { threadID, messageID, mentions, messageReply, senderID } = event;
    
    // Ki·ªÉm tra quy·ªÅn admin
    const threadInfo = await api.getThreadInfo(threadID);
    const isAdmin = threadInfo.adminIDs.some(admin => admin.id === senderID);
    
    if (!isAdmin) {
      return api.sendMessage("üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y! Ch·ªâ qu·∫£n tr·ªã vi√™n m·ªõi ƒë∆∞·ª£c kick ng∆∞·ªùi.", threadID, messageID);
    }

    let userIDToKick;

    if (Object.keys(mentions).length > 0) {
      userIDToKick = Object.keys(mentions)[0];
    } else if (messageReply) {
      userIDToKick = messageReply.senderID;
    } else {
      return api.sendMessage("üö´ Vui l√≤ng tag ng∆∞·ªùi c·∫ßn kick ho·∫∑c reply tin nh·∫Øn c·ªßa ng∆∞·ªùi ƒë√≥!", threadID, messageID);
    }

    // Kh√¥ng cho kick bot
    const botID = api.getCurrentUserID();
    if (userIDToKick === botID) {
      return api.sendMessage("üòÇ ∆† k√¨a, ƒëu·ªïi em ƒëi √†? Em ·ªü l·∫°i gi√∫p m·ªçi ng∆∞·ªùi m√†!", threadID, messageID);
    }

    // Kh√¥ng cho kick ch√≠nh m√¨nh
    if (userIDToKick === senderID) {
      return api.sendMessage("ü§î T·ª± kick m√¨nh √†? Hay ƒë√≥ nh∆∞ng em kh√¥ng cho ph√©p ƒë√¢u!", threadID, messageID);
    }

    // Th·ª±c hi·ªán kick
    await api.removeUserFromGroup(userIDToKick, threadID);
    
    // L·∫•y t√™n ng∆∞·ªùi b·ªã kick
    const userInfo = await api.getUserInfo(userIDToKick);
    const userName = userInfo[userIDToKick]?.name || "Ng∆∞·ªùi d√πng";
    
    return api.sendMessage(`‚úÖ ƒê√£ kick ${userName} ra kh·ªèi nh√≥m th√†nh c√¥ng! üöÄ`, threadID, messageID);
    
  } catch (error) {
    console.error("L·ªói khi kick:", error);
    return api.sendMessage("‚ùå C√≥ l·ªói x·∫£y ra khi kick ng∆∞·ªùi! C√≥ th·ªÉ bot kh√¥ng c√≥ quy·ªÅn ho·∫∑c ng∆∞·ªùi ƒë√≥ l√† admin.", event.threadID, event.messageID);
  }
}

async function processMessage({ api, event, threadID, senderID, nameUser, content }) {
  let attempt = 0, maxAttempts = API_KEYS.length;
  while (attempt < maxAttempts) {
    try {
      const result = await getChatInstance(threadID).sendMessage(JSON.stringify({
        time: getCurrentTimeInVietnam(),
        senderName: nameUser,
        content,
        threadID,
        senderID,
        id_cua_bot: await api.getCurrentUserID(),
      }));
      const response = await result.response;
      const text = await response.text();
      return await handleBotResponse(text, api, event, threadID);
    } catch (err) {
      genAI = new GoogleGenerativeAI(getNextApiKey());
      model = genAI.getGenerativeModel({ model: MODEL_NAME, generationConfig, safetySettings, systemInstruction });
      chatInstances[threadID] = model.startChat({ history: [] });
      attempt++;
    }
  }
  api.sendMessage("‚ùå Kh√¥ng th·ªÉ x·ª≠ l√Ω y√™u c·∫ßu v·ªõi t·∫•t c·∫£ API Key.", threadID, event.messageID);
}

// H√†m x·ª≠ l√Ω response t·ª´ AI
async function handleBotResponse(text, api, event, threadID) {
  let botMsg = {};
  let responseText = "";
  
  try {
    const jsonMatch = text.match(/```json\s*([\s\S]*?)```/) || text.match(/```([\s\S]*?)```/) || text.match(/\{[\s\S]*\}/);
    
    if (jsonMatch) {
      let jsonText = jsonMatch[0];
      jsonText = jsonText.replace(/```json|```/g, '').trim();
      botMsg = JSON.parse(jsonText);
      
      if (botMsg.content && botMsg.content.text) {
        responseText = botMsg.content.text;
      } else {
        responseText = text.replace(/```json|```/g, "").trim();
      }
    } else {
      responseText = text.trim();
    }
  } catch (e) {
    console.error("L·ªói parse JSON:", e);
    responseText = text.replace(/```json|```/g, "").trim();
  }

  if (responseText) {
    addToChatHistory(threadID, "assistant", responseText);
    await api.sendMessage({ body: responseText }, event.threadID, undefined, event.messageID);
  }

  // X·ª≠ l√Ω c√°c h√†nh ƒë·ªông kh√°c
  if (botMsg.nhac?.status && botMsg.nhac.keyword) {
    await playMusic(api, event, botMsg.nhac.keyword);
  }
  if (botMsg.video?.status && botMsg.video.keyword) {
    const keyword = botMsg.video.keyword.toLowerCase();
    if (keyword.includes("tiktok")) {
      const cleanKeyword = keyword.replace(/tiktok/g, "").trim();
      await downloadAndSendTikTok(api, event, cleanKeyword || "trending");
    } else {
      await downloadAndSendVideo(api, event, botMsg.video.keyword);
    }
  }
  if (botMsg.ve_anh?.status && botMsg.ve_anh.prompt) {
    await drawImage(api, event, botMsg.ve_anh.prompt);
  }
  if (botMsg.kiem_tra_tt?.status) {
    await checkInteraction(api, event, botMsg.kiem_tra_tt.type || "all");
  }
  if (botMsg.thong_tin_nhom?.status) {
    await getGroupInfo(api, event);
  }
  if (botMsg.thong_tin_bot?.status) {
    await getBotInfo(api, event);
  }
  if (botMsg.kick_nguoi?.status && botMsg.kick_nguoi.user_id) {
    await handleKickUser(api, event, botMsg.kick_nguoi.user_id);
  }
  
  if (botMsg.hanh_dong) {
    handleActions(botMsg.hanh_dong, api, threadID);
  }
}

// H√†m x·ª≠ l√Ω kick ng∆∞·ªùi t·ª´ AI
async function handleKickUser(api, event, userID) {
  try {
    const { threadID, messageID, senderID } = event;
    
    // Ki·ªÉm tra quy·ªÅn admin
    const threadInfo = await api.getThreadInfo(threadID);
    const isAdmin = threadInfo.adminIDs.some(admin => admin.id === senderID);
    
    if (!isAdmin) {
      return api.sendMessage("üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y! Ch·ªâ qu·∫£n tr·ªã vi√™n m·ªõi ƒë∆∞·ª£c kick ng∆∞·ªùi.", threadID, messageID);
    }

    // Kh√¥ng cho kick bot
    const botID = api.getCurrentUserID();
    if (userID === botID) {
      return api.sendMessage("üòÇ ∆† k√¨a, ƒëu·ªïi em ƒëi √†? Em ·ªü l·∫°i gi√∫p m·ªçi ng∆∞·ªùi m√†!", threadID, messageID);
    }

    // Kh√¥ng cho kick ch√≠nh m√¨nh
    if (userID === senderID) {
      return api.sendMessage("ü§î T·ª± kick m√¨nh √†? Hay ƒë√≥ nh∆∞ng em kh√¥ng cho ph√©p ƒë√¢u!", threadID, messageID);
    }

    // Th·ª±c hi·ªán kick
    await api.removeUserFromGroup(userID, threadID);
    
    // L·∫•y t√™n ng∆∞·ªùi b·ªã kick
    const userInfo = await api.getUserInfo(userID);
    const userName = userInfo[userID]?.name || "Ng∆∞·ªùi d√πng";
    
    return api.sendMessage(`‚úÖ ƒê√£ kick ${userName} ra kh·ªèi nh√≥m th√†nh c√¥ng! üöÄ`, threadID, messageID);
    
  } catch (error) {
    console.error("L·ªói khi kick:", error);
    return api.sendMessage("‚ùå C√≥ l·ªói x·∫£y ra khi kick ng∆∞·ªùi! C√≥ th·ªÉ bot kh√¥ng c√≥ quy·ªÅn ho·∫∑c ng∆∞·ªùi ƒë√≥ l√† admin.", event.threadID, event.messageID);
  }
}

async function handleActions(action, api, threadID) {
  if (action.doi_biet_danh?.status)
    await api.changeNickname(action.doi_biet_danh.biet_danh_moi, action.doi_biet_danh.thread_id, action.doi_biet_danh.user_id);
  if (action.doi_icon_box?.status)
    await api.changeThreadEmoji(action.doi_icon_box.icon, action.doi_icon_box.thread_id);
  if (action.doi_ten_nhom?.status)
    await api.setTitle(action.doi_ten_nhom.ten_moi, action.doi_ten_nhom.thread_id);
  if (action.kick_nguoi_dung?.status)
    await api.removeUserFromGroup(action.kick_nguoi_dung.user_id, action.kick_nguoi_dung.thread_id);
  if (action.add_nguoi_dung?.status)
    await api.addUserToGroup(action.add_nguoi_dung.user_id, action.add_nguoi_dung.thread_id);
}

function getCurrentTimeInVietnam() {
  const vnOffset = 7;
  const utc = new Date().getTime() + new Date().getTimezoneOffset() * 60000;
  const now = new Date(utc + 3600000 * vnOffset);
  return `${now.toLocaleString("vi-VN", { weekday: "long" })} - ${now.toLocaleDateString("vi-VN")} - ${now.toLocaleTimeString("vi-VN")}`;
}

async function searchYouTube(query) {
  try {
    const result = await youtube.GetListByKeyword(query, false, 1);
    const item = result.items[0];
    if (item && item.id) {
      return `https://youtu.be/${item.id}`;
    }
  } catch (e) {
    console.error("L·ªói t√¨m ki·∫øm YouTube:", e);
  }
  return null;
}

// H√†m t·∫£i nh·∫°c t·ª´ YouTube (s·ª≠ d·ª•ng API c·ªßa sing6)
async function playMusic(api, event, query) {
  try {
    const { threadID, messageID } = event;
    const API = "http://theone-api-3416.ddnsgeek.com:3040";

    if (!query) {
      return api.sendMessage("üé∂ C·∫≠u ch∆∞a nh·∫≠p t√™n b√†i h√°t n√®! üòÖ", threadID, messageID);
    }

    const searchUrl = query.includes("youtube.com") || query.includes("youtu.be")
      ? `${API}/?url=${encodeURIComponent(query)}`
      : `${API}/search?q=${encodeURIComponent(query)}&num=1`;

    const res = await axios.get(searchUrl);
    const data = res.data;

    let videoUrl, title, channel, expires;
    if (query.includes("youtube.com") || query.includes("youtu.be")) {
      videoUrl = query;
      title = data.title;
      channel = data.channel;
      expires = data.expires;
    } else {
      if (!data.results || data.results.length === 0) {
        return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y b√†i h√°t n√†o ph√π h·ª£p!", threadID, messageID);
      }
      videoUrl = `https://youtu.be/${data.results[0].videoId}`;
      title = data.results[0].title;
      channel = data.results[0].channel;
      expires = (await axios.get(`${API}/?url=${encodeURIComponent(videoUrl)}`)).data.expires;
    }

    const resVideo = await axios.get(`${API}/?url=${encodeURIComponent(videoUrl)}`);
    const media = resVideo.data.media.find(m => m.quality.includes("kbps")); // Ch·ªçn audio

    if (!media) {
      return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y ƒë·ªãnh d·∫°ng audio ph√π h·ª£p!", threadID, messageID);
    }

    const filePath = pathModule.join(__dirname, "cache", media.filename);
    const writer = fs.createWriteStream(filePath);

    const response = await axios({
      url: media.url,
      method: "GET",
      responseType: "stream"
    });

    response.data.pipe(writer);

    writer.on("finish", () => {
      api.sendMessage({
        body: `üé∂ ƒêang m·ªü: ${title}\nüì∫ K√™nh: ${channel}\nüì¶ ${media.quality} (${media.codec}, ${media.size})\n‚åõ ${expires}`,
        attachment: fs.createReadStream(filePath)
      }, threadID, () => fs.unlinkSync(filePath), messageID);
    });

    writer.on("error", () => {
      api.sendMessage("‚ùå T·∫£i file audio th·∫•t b·∫°i!", threadID, messageID);
    });
  } catch (e) {
    console.error("L·ªói t·∫£i nh·∫°c:", e);
    api.sendMessage("‚ùå L·ªói khi t·∫£i nh·∫°c! üòì", event.threadID, event.messageID);
  }
}

// H√†m t·∫£i video t·ª´ YouTube (m·∫∑c ƒë·ªãnh 480p, ch·ªçn video ƒë·∫ßu ti√™n)
async function downloadAndSendVideo(api, event, query) {
  try {
    const { threadID, messageID } = event;
    const API = "http://theone-api-3416.ddnsgeek.com:3040";

    if (!query) {
      return api.sendMessage("üìπ C·∫≠u ch∆∞a nh·∫≠p t√™n video n√®! üòÖ", threadID, messageID);
    }

    const searchUrl = query.includes("youtube.com") || query.includes("youtu.be")
      ? `${API}/?url=${encodeURIComponent(query)}`
      : `${API}/search?q=${encodeURIComponent(query)}&num=1`;

    const res = await axios.get(searchUrl);
    const data = res.data;

    let videoUrl, title, channel, expires;
    if (query.includes("youtube.com") || query.includes("youtu.be")) {
      videoUrl = query;
      title = data.title;
      channel = data.channel;
      expires = data.expires;
    } else {
      if (!data.results || data.results.length === 0) {
        return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y video n√†o ph√π h·ª£p!", threadID, messageID);
      }
      videoUrl = `https://youtu.be/${data.results[0].videoId}`;
      title = data.results[0].title;
      channel = data.results[0].channel;
      expires = (await axios.get(`${API}/?url=${encodeURIComponent(videoUrl)}`)).data.expires;
    }

    const resVideo = await axios.get(`${API}/?url=${encodeURIComponent(videoUrl)}`);
    const media = resVideo.data.media.find(m => m.quality === "480p"); // Ch·ªçn 480p

    if (!media) {
      return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y ƒë·ªãnh d·∫°ng 480p cho video n√†y!", threadID, messageID);
    }

    const filePath = pathModule.join(__dirname, "cache", media.filename);
    const writer = fs.createWriteStream(filePath);

    const response = await axios({
      url: media.url,
      method: "GET",
      responseType: "stream"
    });

    response.data.pipe(writer);

    writer.on("finish", () => {
      const stats = fs.statSync(filePath);
      const fileSize = stats.size;

      if (fileSize > 48 * 1024 * 1024) {
        api.sendMessage("‚ùå Video qu√° l·ªõn (>48MB), kh√¥ng th·ªÉ g·ª≠i!", threadID, messageID);
        fs.unlinkSync(filePath);
        return;
      }

      api.sendMessage({
        body: `üìπ ƒêang m·ªü: ${title}\nüì∫ K√™nh: ${channel}\nüì¶ 480p (${media.codec}, ${media.size})\n‚åõ ${expires}`,
        attachment: fs.createReadStream(filePath)
      }, threadID, () => fs.unlinkSync(filePath), messageID);
    });

    writer.on("error", () => {
      api.sendMessage("‚ùå T·∫£i file video th·∫•t b·∫°i!", threadID, messageID);
    });
  } catch (e) {
    console.error("L·ªói t·∫£i video:", e);
    api.sendMessage("‚ùå L·ªói khi t·∫£i video! üòì", event.threadID, event.messageID);
  }
}

async function downloadAndSendTikTok(api, event, keyword) {
  try {
    const { threadID, messageID } = event;

    const response = await axios.get(`https://www.tikwm.com/api/feed/search`, {
      params: { keywords: keyword, count: 1, cursor: 0, HD: 1 },
      headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }
    });

    const result = response.data.data.videos;
    if (!result || result.length === 0) {
      return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y video TikTok n√†o ph√π h·ª£p.", threadID, messageID);
    }

    const video = result[0];
    const {
      digg_count,
      comment_count,
      play_count,
      share_count,
      download_count,
      duration,
      region,
      title,
      author,
      play,
      wmplay,
      cover
    } = video;

    const nickname = author?.nickname || 'Kh√¥ng r√µ';
    const unique_id = author?.unique_id || 'Kh√¥ng r√µ';
    const video_url = play || wmplay || '';

    if (!video_url) {
      return api.sendMessage("‚ùå Kh√¥ng th·ªÉ t·∫£i video TikTok n√†y.", threadID, messageID);
    }

    const res = await axios.get(video_url, { responseType: "stream" });
    const videoPath = pathModule.join(__dirname, "/cache/tiktok_video.mp4");
    const writer = fs.createWriteStream(videoPath);
    
    res.data.pipe(writer);

    writer.on("finish", () => {
      api.sendMessage({
        body: `[ TIKTOK VIDEO ]\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nüìù ${title}\nüë§ T√°c gi·∫£: ${nickname}\nüÜî ID: ${unique_id}\nüåç Qu·ªëc gia: ${region || 'Kh√¥ng c√≥'}\n‚è±Ô∏è Th·ªùi gian: ${duration} gi√¢y\n‚ù§Ô∏è L∆∞·ª£t th√≠ch: ${formatNumber(digg_count)}\nüí¨ B√¨nh lu·∫≠n: ${formatNumber(comment_count)}\nüëÄ L∆∞·ª£t xem: ${formatNumber(play_count)}\nüì§ Chia s·∫ª: ${formatNumber(share_count)}\nüì• T·∫£i v·ªÅ: ${formatNumber(download_count)}\nüì± T·∫£i b·ªüi Nhi`,
        attachment: fs.createReadStream(videoPath)
      }, threadID, () => {
        if (fs.existsSync(videoPath)) {
          fs.unlinkSync(videoPath);
        }
      }, messageID);
    });

    writer.on("error", (err) => {
      console.log('L·ªói t·∫£i video TikTok:', err.message);
      api.sendMessage("‚ùå C√≥ l·ªói khi t·∫£i video TikTok!", threadID, messageID);
    });

  } catch (err) {
    console.log('L·ªói khi g·ªçi TikWM API:', err.message);
    api.sendMessage("‚ùå C√≥ l·ªói khi t·∫£i video TikTok. Vui l√≤ng th·ª≠ l·∫°i sau!", event.threadID, event.messageID);
  }
}

async function drawImage(api, event, prompt) {
  try {
    const { threadID, messageID } = event;

    let translatedPrompt;
    try {
      translatedPrompt = await translatePrompt(prompt);
    } catch (error) {
      console.error('L·ªói khi d·ªãch:', error);
      return api.sendMessage(
        '‚ùå L·ªói khi d·ªãch vƒÉn b·∫£n. Vui l√≤ng th·ª≠ l·∫°i sau.',
        threadID,
        messageID
      );
    }

    const API = `https://image.pollinations.ai/prompt/${encodeURIComponent(translatedPrompt)}`;
    const timeout = 25000;

    try {
      const response = await axios.get(API, { 
        responseType: 'arraybuffer',
        timeout: timeout
      });

      if (response.data) {
        const imagePath = pathModule.join(__dirname, `/cache/imagine_${Date.now()}.png`);
        fs.writeFileSync(imagePath, Buffer.from(response.data, 'binary'));
        
        api.sendMessage(
          {
            body: "üé® ·∫¢nh c·ªßa b·∫°n ƒë√¢y! ƒê·∫πp kh√¥ng n√†o? ü§©",
            attachment: fs.createReadStream(imagePath),
          },
          threadID,
          (err) => {
            if (err) {
              console.error("L·ªói khi g·ª≠i ·∫£nh:", err);
              api.sendMessage("‚ùå L·ªói khi g·ª≠i ·∫£nh.", threadID);
            }
            if (fs.existsSync(imagePath)) {
              fs.unlinkSync(imagePath);
            }
          },
          messageID
        );
      } else {
        api.sendMessage('‚ùå ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i sau', threadID, messageID);
      }
    } catch (error) {
      console.error("L·ªói khi t·∫°o ·∫£nh:", error);
      api.sendMessage('‚ùå ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i sau', threadID, messageID);
    }
  } catch (error) {
    console.error("L·ªói drawImage:", error);
    api.sendMessage('‚ùå ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i sau', event.threadID, event.messageID);
  }
}

async function translatePrompt(prompt) {
  const translateAPI = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(prompt)}&langpair=vi|en`;
  
  try {
    const response = await axios.get(translateAPI, { timeout: 10000 });
    const translatedText = response.data.responseData.translatedText;
    return translatedText || prompt;
  } catch (error) {
    console.error('L·ªói d·ªãch API:', error);
    return prompt;
  }
}

async function checkInteraction(api, event, type = "all") {
  try {
    const { threadID, messageID } = event;
    const filePath = pathModule.join(ttPath, `${threadID}.json`);
    
    if (!fs.existsSync(filePath)) {
      return api.sendMessage("‚ö†Ô∏è Ch∆∞a c√≥ d·ªØ li·ªáu t∆∞∆°ng t√°c trong nh√≥m n√†y!", threadID, messageID);
    }

    const threadInfo = await api.getThreadInfo(threadID);
    const totalMembers = threadInfo.participantIDs.length;

    const data = JSON.parse(fs.readFileSync(filePath));
    let list = [];

    if (type === "all") list = data.total;
    else if (type === "week") list = data.week;
    else if (type === "day") list = data.day;
    else list = data.total;

    const sorted = list.slice().sort((a, b) => b.count - a.count);

    let resultMessage = `üìä K·∫æT QU·∫¢ KI·ªÇM TRA T∆Ø∆†NG T√ÅC C·ª¶A T·∫§T C·∫¢ TH√ÄNH VI√äN\n\n`;

    for (let i = 0; i < sorted.length; i++) {
      const user = sorted[i];
      let icon;
      
      if (user.count < 20) icon = "‚ùå";
      else if (user.count < 40) icon = "‚ö†Ô∏è";
      else if (user.count < 100) icon = "üîµ";
      else if (user.count < 500) icon = "üü¢";
      else icon = "‚úÖ";

      try {
        const userInfo = await api.getUserInfo(user.id);
        const userName = userInfo[user.id]?.name || "Ng∆∞·ªùi d√πng Facebook";
        resultMessage += `${i + 1}. ${icon} ${userName}\n   ‚îî‚îÄ Tin nh·∫Øn: ${user.count}\n`;
      } catch (error) {
        resultMessage += `${i + 1}. ${icon} User ID: ${user.id}\n   ‚îî‚îÄ Tin nh·∫Øn: ${user.count}\n`;
      }
    }

    resultMessage += `\nüí¨ T·ªïng s·ªë th√†nh vi√™n: ${totalMembers}\nüìà Lo·∫°i t∆∞∆°ng t√°c: ${type.toUpperCase()}\n\n‚ùå D∆∞·ªõi 20 tin nh·∫Øn\n‚ö†Ô∏è D∆∞·ªõi 40 tin nh·∫Øn\nüîµ D∆∞·ªõi 100 tin nh·∫Øn\nüü¢ D∆∞·ªõi 500 tin nh·∫Øn\n‚úÖ Tr√™n 500 tin nh·∫Øn\nEm ƒë√£ ki·ªÉm tra xong ·∫°!`;

    if (threadInfo.imageSrc) {
      try {
        const response = await axios.get(threadInfo.imageSrc, { responseType: 'stream' });
        const imagePath = pathModule.join(__dirname, '/cache/group_avatar_checktt.png');
        const writer = fs.createWriteStream(imagePath);
        
        response.data.pipe(writer);
        
        writer.on('finish', () => {
          api.sendMessage({
            body: resultMessage,
            attachment: fs.createReadStream(imagePath)
          }, threadID, () => {
            if (fs.existsSync(imagePath)) {
              fs.unlinkSync(imagePath);
            }
          }, messageID);
        });
        
        writer.on('error', (error) => {
          console.error("L·ªói khi t·∫£i ·∫£nh nh√≥m:", error);
          api.sendMessage(resultMessage, threadID, messageID);
        });
      } catch (error) {
        console.error("L·ªói khi l·∫•y ·∫£nh nh√≥m:", error);
        api.sendMessage(resultMessage, threadID, messageID);
      }
    } else {
      return api.sendMessage(resultMessage, threadID, messageID);
    }
  } catch (error) {
    console.error("L·ªói khi ki·ªÉm tra t∆∞∆°ng t√°c:", error);
    return api.sendMessage("‚ùå C√≥ l·ªói khi ki·ªÉm tra t∆∞∆°ng t√°c. Vui l√≤ng th·ª≠ l·∫°i sau!", event.threadID, event.messageID);
  }
}

async function getGroupInfo(api, event) {
  try {
    const { threadID, messageID } = event;
    
    const rentDataPath = pathModule.join(__dirname, 'data', 'thuebot.json');
    let rentData = [];
    
    if (fs.existsSync(rentDataPath)) {
      try {
        rentData = JSON.parse(fs.readFileSync(rentDataPath, 'utf8'));
      } catch (e) {
        console.error('L·ªói ƒë·ªçc file thuebot.json:', e);
      }
    }
    
    const rentInfo = rentData.find(item => item.t_id == threadID);
    
    const threadInfo = await api.getThreadInfo(threadID);
    const threadName = threadInfo.threadName || "Kh√¥ng c√≥ t√™n";
    const approvalMode = threadInfo.approvalMode ? "b·∫≠t" : "t·∫Øt";
    const emoji = threadInfo.emoji || "üëç";
    const totalMembers = threadInfo.participantIDs.length;
    
    let gendernam = [], gendernu = [], bede = [];
    for (let z in threadInfo.userInfo) {
      const gioitinhone = threadInfo.userInfo[z].gender;
      const nName = threadInfo.userInfo[z].name;
      if (gioitinhone === "MALE") gendernam.push(nName);
      else if (gioitinhone === "FEMALE") gendernu.push(nName);
      else bede.push(nName);
    }
    const nam = gendernam.length;
    const nu = gendernu.length;
    const bedeCount = bede.length;
    
    const adminName = [];
    for (const arrayAdmin of threadInfo.adminIDs) {
      try {
        const name = (await api.getUserInfo(arrayAdmin.id))[arrayAdmin.id]?.name || "Kh√¥ng x√°c ƒë·ªãnh";
        adminName.push(name);
      } catch (error) {
        adminName.push("Kh√¥ng x√°c ƒë·ªãnh");
      }
    }
    
    let message = `‚≠êÔ∏è Box: ${threadName}\n`;
    
    if (rentInfo) {
      try {
        const userInfo = await api.getUserInfo(rentInfo.id);
        const userName = userInfo[rentInfo.id]?.name || "Kh√¥ng r√µ";
        message += `üë§ Ng∆∞·ªùi thu√™: ${userName}\n`;
      } catch (error) {
        message += `üë§ Ng∆∞·ªùi thu√™: Kh√¥ng r√µ\n`;
      }
    } else {
      message += `üë§ Ng∆∞·ªùi thu√™: kh√¥ng r√µ\n`;
    }
    
    message += `üéÆ ID: ${threadID}\n`;
    message += `üì± Ph√™ duy·ªát: ${approvalMode}\n`;
    message += `üê∞ Emoji: ${emoji}\n`;
    message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    message += `üìå Th√†nh vi√™n: ${totalMembers} th√†nh vi√™n\n`;
    message += `S·ªë tv nam üßë‚Äçü¶∞: ${nam} th√†nh vi√™n\n`;
    message += `S·ªë tv n·ªØ üë©‚Äçü¶∞: ${nu} th√†nh vi√™n\n`;
    message += `S·ªë tv kh√¥ng x√°c ƒë·ªãnh: ${bedeCount} th√†nh vi√™n\n`;
    
    if (adminName.length > 0) {
      message += `\nüïµÔ∏è‚Äç‚ôÇÔ∏è QTV (${adminName.length} ng∆∞·ªùi):\n`;
      for (let i = 0; i < adminName.length; i++) {
        message += `${i + 1}. ${adminName[i]}\n`;
      }
      message += `\n`;
    } else {
      message += `\nüïµÔ∏è‚Äç‚ôÇÔ∏è QTV (0 ng∆∞·ªùi)\n\n`;
    }
    
    message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    
    if (rentInfo) {
      message += `üìÜ Ng√†y Thu√™: ${rentInfo.time_start}\n`;
      message += `‚è≥ H·∫øt H·∫°n: ${rentInfo.time_end}\n`;
      
      const endDate = new Date(rentInfo.time_end.split('/').reverse().join('/'));
      const now = new Date();
      const timeDiff = endDate.getTime() - now.getTime();
      
      if (timeDiff > 0) {
        const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
        const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        message += `üìå Th·ªùi gian: ${days} ng√†y ${hours} gi·ªù l√† h·∫øt h·∫°n.\n`;
      } else {
        message += `üìå Th·ªùi gian: 0 ng√†y 0 gi·ªù l√† h·∫øt h·∫°n.\n`;
      }
    } else {
      message += `üìÜ Ng√†y Thu√™: ch∆∞a thu√™\n`;
    }
    
    if (threadInfo.imageSrc) {
      try {
        const imagePath = pathModule.join(__dirname, '/cache/group_avatar.jpg');
        const writer = fs.createWriteStream(imagePath);
        const response = await axios.get(threadInfo.imageSrc, { responseType: 'stream' });
        
        response.data.pipe(writer);
        
        writer.on('finish', () => {
          api.sendMessage({
            body: message,
            attachment: fs.createReadStream(imagePath)
          }, threadID, () => {
            if (fs.existsSync(imagePath)) {
              fs.unlinkSync(imagePath);
            }
          }, messageID);
        });
        
        writer.on('error', (error) => {
          console.error("L·ªói khi t·∫£i ·∫£nh nh√≥m:", error);
          api.sendMessage(message, threadID, messageID);
        });
      } catch (error) {
        console.error("L·ªói khi l·∫•y ·∫£nh nh√≥m:", error);
        api.sendMessage(message, threadID, messageID);
      }
    } else {
      api.sendMessage(message, threadID, messageID);
    }
    
  } catch (error) {
    console.error("L·ªói khi l·∫•y th√¥ng tin nh√≥m:", error);
    api.sendMessage("‚ùå C√≥ l·ªói khi l·∫•y th√¥ng tin nh√≥m. Vui l√≤ng th·ª≠ l·∫°i sau!", event.threadID, event.messageID);
  }
}

async function getBotInfo(api, event) {
  try {
    const { threadID, messageID } = event;
    const start = Date.now();

    api.sendMessage("‚è≥ ƒêang l·∫•y th√¥ng tin c·∫•u h√¨nh h·ªá th·ªëng, vui l√≤ng ch·ªù...", threadID, messageID);

    const [
      cpu, mem, osInfo, disks, usage, gpuData,
      battery, ping, baseboard, graphics, memLayout, system
    ] = await Promise.all([
      si.cpu(),
      si.mem(),
      si.osInfo(),
      si.diskLayout(),
      pidusage(process.pid),
      si.graphics(),
      si.battery(),
      si.inetLatency(),
      si.baseboard(),
      si.graphics(),
      si.memLayout(),
      si.system()
    ]);

    const gpuList = gpuData.controllers.map((gpu, index) => {
      return `‚Ä¢ GPU ${index + 1}:
  - T√™n: ${gpu.vendor || "Kh√¥ng r√µ"} ${gpu.model || "Kh√¥ng r√µ"}
  - VRAM: ${gpu.vram ? gpu.vram + " MB" : "Kh√¥ng r√µ"}`;
    }).join("\n");

    const displayList = graphics.displays.map((d, i) => {
      return `‚Ä¢ M√†n h√¨nh ${i + 1}:
  - Model: ${d.model || "Kh√¥ng r√µ"}
  - Ch√≠nh: ${d.main ? "‚úÖ" : "‚ùå"}`;
    }).join("\n");

    const ramInfo = memLayout.map((m, i) =>
      `‚Ä¢ Thanh ${i + 1}: ${(m.size / 1024 / 1024 / 1024).toFixed(1)} GB - ${m.type || "?"}, ${m.clockSpeed || "?"} MHz, H√£ng: ${m.manufacturer || "?"}`
    ).join("\n");

    const deviceInfo = battery.hasBattery
      ? `üñ•Ô∏è ùóßùóõùóúùóòÃÇÃÅùóß ùóïùóúÃ£:
‚Ä¢ H√£ng: ${system.manufacturer || "Kh√¥ng r√µ"}
‚Ä¢ Model: ${system.model || "Kh√¥ng r√µ"}

`
      : "";

    const msg =
`ü§ñ === ùóßùóõùó¢ÃÇùó°ùóö ùóßùóúùó° ùóõùóòÃ£ÃÇ ùóßùóõùó¢ÃÇÃÅùó°ùóö ùóïùó¢ùóß ùó°ùóõùóú ===

${deviceInfo}üîπ ùóïùó¢ ùó†ùóîÃ£ùóñùóõ ùóñùóõùó®Ãâ
‚Ä¢ T√™n: ${baseboard.manufacturer} ${baseboard.model || "Kh√¥ng r√µ"}

üîπ ùóñùó£ùó®
‚Ä¢ T√™n: ${cpu.manufacturer} ${cpu.brand}
‚Ä¢ Nh√¢n: ${cpu.cores}, Lu·ªìng: ${cpu.physicalCores}
‚Ä¢ T·ªëc ƒë·ªô: ${cpu.speed} GHz
‚Ä¢ M·ª©c s·ª≠ d·ª•ng: ${usage.cpu.toFixed(1)}%

üîπ ÔøΩ_Rùóîùó†
‚Ä¢ T·ªïng: ${(mem.total / 1024 / 1024 / 1024).toFixed(1)} GB
‚Ä¢ Tr·ªëng: ${(mem.available / 1024 / 1024 / 1024).toFixed(1)} GB
‚Ä¢ Bot ƒëang d√πng: ${formatBytes(usage.memory)}

üîπ ùóñùóõùóú ùóßùóúùóòÃÇÃÅùóß ÔøΩ_Rùóîùó†
${ramInfo}

üîπ ùó¢ÃõÃâ ƒêùóúÃÉùóî
${disks.map((d, i) =>
  `‚Ä¢ ·ªî ${i + 1}: ${d.name || "N/A"} - ${d.interfaceType || "?"}, ${(d.size / 1024 / 1024 / 1024).toFixed(0)} GB`
).join("\n")}

üîπ ùóöùó£ùó®
${gpuList}

üîπ ùó†ùóîÃÄùó° ùóõùóúÃÄùó°ùóõ
${displayList}

${battery.hasBattery ? `üîπ ùó£ùóúùó°
‚Ä¢ Dung l∆∞·ª£ng: ${battery.percent !== null && battery.percent !== undefined ? battery.percent + "%" : "Kh√¥ng r√µ"}
‚Ä¢ Tr·∫°ng th√°i: ${battery.isCharging ? "ƒêang s·∫°c" : "Kh√¥ng s·∫°c"}` : "üîå ùó£ùóúùó°:X"}

üîπ ùó†ùóîÃ£ùó°ùóö
‚Ä¢ Ping m·∫°ng hi·ªán t·∫°i: ${ping !== null && ping !== undefined ? ping + " ms" : "Kh√¥ng r√µ"}

üîπ ùóõùóòÃ£ÃÇ ƒêùóúùóòÃÇÃÄùó® ùóõùóîÃÄùó°ùóõ
‚Ä¢ N·ªÅn t·∫£ng: ${osInfo.platform}
‚Ä¢ Phi√™n b·∫£n: ${osInfo.build || osInfo.release}
‚Ä¢ Ki·∫øn tr√∫c: ${osInfo.arch}
‚Ä¢ Uptime m√°y: ${formatUptime(os.uptime())}
‚Ä¢ Uptime bot: ${formatUptime(process.uptime())}

üîπ ùóßùó¢ÃÇÃÅùóñ ƒêùó¢Ã£ÃÇ ùóïùó¢ùóß
‚Ä¢ Ph·∫£n h·ªìi: ${(Date.now() - start)} ms

‚ú® Bot Nhi - Phi√™n b·∫£n 2.3.2`;

    return api.sendMessage(msg, threadID, messageID);
  } catch (err) {
    console.error(err);
    return api.sendMessage(`‚ö†Ô∏è L·ªói khi l·∫•y th√¥ng tin h·ªá th·ªëng:\n${err.message}`, event.threadID, event.messageID);
  }
}

// Xo√° file cache qu√° 1h
setInterval(() => {
  const cacheDir = pathModule.join(__dirname, "cache");
  if (!fs.existsSync(cacheDir)) return;
  const now = Date.now();
  for (const file of fs.readdirSync(cacheDir)) {
    const filePath = pathModule.join(cacheDir, file);
    if (fs.statSync(filePath).mtimeMs < now - 3600000) {
      fs.unlinkSync(filePath);
    }
  }
}, 3600000);
=======
const fs = require('fs');
const path = require('path');
const { simi } = require('./../../includes/controllers/sim.js');

module.exports.config = {
    name: 'sim',
    version: '1.1.3',
    hasPermssion: 1,
    credits: 'no',
    description: 'Tr√≤ truy·ªán c√πng simi chat, c√≥ th·ªÉ b·∫≠t/t·∫Øt',
    commandCategory: 'Admin',
    usages: '[on/off]',
    cooldowns: 2,
};

const dataFilePath = path.resolve(__dirname, 'data/bot.json');

function loadData() {
    if (!fs.existsSync(dataFilePath)) return {};
    try {
        return JSON.parse(fs.readFileSync(dataFilePath, 'utf8'));
    } catch (e) {
        console.error('L·ªói khi t·∫£i d·ªØ li·ªáu:', e);
        return {};
    }
}

function saveData(data) {
    try {
        fs.writeFileSync(dataFilePath, JSON.stringify(data, null, 2), 'utf8');
    } catch (e) {
        console.error('L·ªói khi l∆∞u d·ªØ li·ªáu:', e);
    }
}

module.exports.run = async function({ api, event, args }) {
    const threadID = event.threadID;
    const data = loadData();

    if (args[0] === 'on') {
        data[threadID] = true;
        saveData(data);
        return api.sendMessage('ƒê√£ b·∫≠t ch·ª©c nƒÉng tr√≤ chuy·ªán c√πng bot trong nh√≥m n√†y!', threadID);
    } else if (args[0] === 'off') {
        data[threadID] = false;
        saveData(data);
        return api.sendMessage('ƒê√£ t·∫Øt ch·ª©c nƒÉng tr√≤ chuy·ªán c√πng bot trong nh√≥m n√†y!', threadID);
    } else {
        return api.sendMessage('Vui l√≤ng s·ª≠ d·ª•ng: [on/off] ƒë·ªÉ b·∫≠t ho·∫∑c t·∫Øt t√≠nh nƒÉng.', threadID);
    }
};

module.exports.handleEvent = async function({ api, event }) {
    const threadID = event.threadID;
    const message = event.body?.toLowerCase();

    const data = loadData();
    if (!data[threadID]) return;

    const keywords = ['Pie', 'Bot', 'bot ƒë√¢u', 'bot off', 'bot ∆°i', 'bot x·ªãn', 
        'k√™u m·ªçi ng∆∞·ªùi l√™n t∆∞∆°ng t√°c ƒëi bot', 'ch√†o bot', 'hello bot', 'pie', 'Pie', 'bye bot'];
    const responses = [
        'k√™u em c√≥ g√¨ hok üíì', '∆°i em nghe n√®', 'c√≥ g√¨ hog em n√®',
        'em n√®', 'k√™u em c√≥ g√¨ kh√¥ng', 'üíû em nghe', 'em ƒë√¢y'
    ];

    if (!message || !keywords.includes(message)) return;

    const randomResponse = responses[Math.floor(Math.random() * responses.length)];
    api.sendMessage(
        { body: randomResponse },
        threadID,
        (err, data) => {
            if (err) return console.error(err);
            global.client.handleReply.push({ name: this.config.name, messageID: data.messageID });
        },
        event.messageID
    );
};

module.exports.handleReply = async function({ handleReply: $, api, event }) {
    const threadID = event.threadID;
    const data = loadData();

    if (!data[threadID]) return;

    try {
        const response = await simi('ask', event.body);
        if (response.error || !response.answer) {
            return api.sendMessage('Bot g·∫∑p s·ª± c·ªë khi tr·∫£ l·ªùi. Vui l√≤ng th·ª≠ l·∫°i sau!', threadID, event.messageID);
        }
        api.sendMessage(
            { body: response.answer },
            threadID,
            (err, data) => {
                if (err) return console.error(err);
                global.client.handleReply.push({ name: this.config.name, messageID: data.messageID });
            },
            event.messageID
        );
    } catch (error) {
        console.error(error);
        api.sendMessage('C√≥ l·ªói x·∫£y ra trong qu√° tr√¨nh x·ª≠ l√Ω.', threadID, event.messageID);
    }
};
>>>>>>> 4398b3a5fd9045b8de57d496d6bc325c61036aaa
